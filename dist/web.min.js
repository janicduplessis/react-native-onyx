!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t(require("fast-equals"),require("underscore"),require("react-dom"),require("idb-keyval"),require("lodash/transform"),require("react")):"function"==typeof define&&define.amd?define(["fast-equals","underscore","react-dom","idb-keyval","lodash/transform","react"],t):"object"==typeof exports?exports["react-native-onyx/web"]=t(require("fast-equals"),require("underscore"),require("react-dom"),require("idb-keyval"),require("lodash/transform"),require("react")):e["react-native-onyx/web"]=t(e["fast-equals"],e.underscore,e["react-dom"],e["idb-keyval"],e["lodash/transform"],e.react)}(self,((e,t,n,s,r,i)=>(()=>{var o={378:(e,t,n)=>{"use strict";function s(e){return e}function r(){}function i(){}function o(){}n.r(t),n.d(t,{decorateWithMetrics:()=>s,getMetrics:()=>r,printMetrics:()=>i,resetMetrics:()=>o})},703:(e,t,n)=>{"use strict";var s=n(414);function r(){}function i(){}i.resetWarningCache=r,e.exports=function(){function e(e,t,n,r,i,o){if(o!==s){var a=new Error("Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types");throw a.name="Invariant Violation",a}}function t(){return e}e.isRequired=e;var n={array:e,bool:e,func:e,number:e,object:e,string:e,symbol:e,any:e,arrayOf:t,element:e,elementType:e,instanceOf:t,node:e,objectOf:t,oneOf:t,oneOfType:t,shape:t,exact:t,checkPropTypes:i,resetWarningCache:r};return n.PropTypes=n,n}},697:(e,t,n)=>{e.exports=n(703)()},414:e=>{"use strict";e.exports="SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED"},746:t=>{"use strict";t.exports=e},802:e=>{"use strict";e.exports=s},407:e=>{"use strict";e.exports=r},156:e=>{"use strict";e.exports=i},111:e=>{"use strict";e.exports=n},952:e=>{"use strict";e.exports=t}},a={};function c(e){var t=a[e];if(void 0!==t)return t.exports;var n=a[e]={exports:{}};return o[e](n,n.exports,c),n.exports}c.n=e=>{var t=e&&e.__esModule?()=>e.default:()=>e;return c.d(t,{a:t}),t},c.d=(e,t)=>{for(var n in t)c.o(t,n)&&!c.o(e,n)&&Object.defineProperty(e,n,{enumerable:!0,get:t[n]})},c.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(e){if("object"==typeof window)return window}}(),c.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),c.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})};var l={};return(()=>{"use strict";c.r(l),c.d(l,{default:()=>De,withOnyx:()=>$e});var e=c(746),t=c(952),n=c.n(t);let s=()=>{};function r(e){s({message:`[Onyx] ${e}`,level:"alert"})}function i(e){s({message:`[Onyx] ${e}`,level:"info"})}function o(e){return null!=e&&"object"==typeof e&&"[object RegExp]"!==Object.prototype.toString.call(e)&&"[object Date]"!==Object.prototype.toString.call(e)&&!Array.isArray(e)}function a(e,t){let s=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];return n().isArray(t)||null==t?t:function(e,t){let n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];const s={};if(o(e)){const r=Object.keys(e);for(let i=0;i<r.length;++i){const o=r[i],a=null===e[o]||null===t[o];n&&a||(s[o]=e[o])}}const r=Object.keys(t);for(let i=0;i<r.length;++i){const c=r[i],l=n&&null===t[c];if(void 0!==t[c]&&!l){const r=o(t[c]);r&&e[c]?n&&!r||(s[c]=a(e[c],t[c],n)):n&&null===t[c]||(s[c]=t[c])}}return s}(e,t,s)}const u={areObjectsEmpty:function(e,t){return"object"==typeof e&&"object"==typeof t&&n().isEmpty(e)&&n().isEmpty(t)},fastMerge:a,removeNestedNullValues:function(e){return"object"!=typeof e||n().isArray(e)?e:a(e,e)}},y=n().negate(n().isUndefined),h=new class{constructor(){this.storageKeys=new Set,this.recentKeys=new Set,this.storageMap={},this.pendingPromises=new Map,n().bindAll(this,"getAllKeys","getValue","hasCacheForKey","addKey","set","drop","merge","hasPendingTask","getTaskPromise","captureTask","removeLeastRecentlyUsedKeys","setRecentKeysLimit")}getAllKeys(){return Array.from(this.storageKeys)}getValue(e){return this.addToAccessedKeys(e),this.storageMap[e]}hasCacheForKey(e){return y(this.storageMap[e])}addKey(e){this.storageKeys.add(e)}set(e,t){return this.addKey(e),this.addToAccessedKeys(e),this.storageMap[e]=t,t}drop(e){delete this.storageMap[e],this.storageKeys.delete(e),this.recentKeys.delete(e)}merge(e){if(!n().isObject(e)||n().isArray(e))throw new Error("data passed to cache.merge() must be an Object of onyx key/value pairs");this.storageMap=Object.assign({},u.fastMerge(this.storageMap,e,!1));const t=this.getAllKeys(),s=n().keys(e);this.storageKeys=new Set([...t,...s]),n().each(s,(e=>this.addToAccessedKeys(e)))}hasPendingTask(e){return y(this.pendingPromises.get(e))}getTaskPromise(e){return this.pendingPromises.get(e)}captureTask(e,t){const n=t.finally((()=>{this.pendingPromises.delete(e)}));return this.pendingPromises.set(e,n),n}addToAccessedKeys(e){this.recentKeys.delete(e),this.recentKeys.add(e)}removeLeastRecentlyUsedKeys(){let e=this.recentKeys.size-this.maxRecentKeysSize;if(e<=0)return;const t=this.recentKeys.values(),n=[];for(;e>0;){const s=t.next().value;n.push(s),e--}for(let e=0;e<n.length;++e)delete this.storageMap[n[e]],this.recentKeys.delete(n[e])}setRecentKeysLimit(e){this.maxRecentKeysSize=e}hasValueChanged(t,n){return!(0,e.deepEqual)(this.storageMap[t],n)}};function d(e,t){return n().isString(e)&&n().isString(t)&&e.startsWith(t)}function f(e){for(var t=arguments.length,s=new Array(t>1?t-1:0),r=1;r<t;r++)s[r-1]=arguments[r];return n().isFunction(e)?e(...s):e}var p=c(407),m=c.n(p);let g=!1;function v(e){g=e}function k(e,t,s,r,i){if(!g)return;const o={};i&&(o.keyThatChanged=i),n().isObject(s)&&n().isObject(t)?o.difference=function e(t,s){return m()(t,((t,r,i)=>{n().isEqual(r,s[i])||(t[i]=n().isObject(r)&&n().isObject(s[i])?e(r,s[i]):r)}))}(t,s):(o.previousValue=t,o.newValue=s),console.debug(`[Onyx-Debug] ${e.displayName} setState() called. Subscribed to key '${e.key}' (${r})`,o)}var b=c(802);let O;const S=()=>(O||(O=(0,b.createStore)("OnyxDB","keyvaluepairs")),O),x={setItem:(e,t)=>(0,b.set)(e,t,S()),multiGet:e=>(0,b.getMany)(e,S()).then((t=>n().map(t,((t,n)=>[e[n],t])))),multiMerge:e=>S()("readwrite",(t=>Promise.all(n().map(e,(e=>{let[n]=e;return(0,b.promisifyRequest)(t.get(n))}))).then((s=>{const r=n().map(e,((e,n)=>{let[r,i]=e;const o=s[n],a=u.fastMerge(o,i);return(0,b.promisifyRequest)(t.put(a,r))}));return Promise.all(r)})))),mergeItem:(e,t,n)=>x.setItem(e,n),multiSet:e=>(0,b.setMany)(e,S()),clear:()=>(0,b.clear)(S()),setMemoryOnlyKeys:()=>{},getAllKeys:()=>(0,b.keys)(S()),getItem:e=>(0,b.get)(e,S()).then((e=>void 0===e?null:e)),removeItem:e=>(0,b.del)(e,S()),removeItems:e=>(0,b.delMany)(e,S()),getDatabaseSize(){if(!window.navigator||!window.navigator.storage)throw new Error("StorageManager browser API unavailable");return window.navigator.storage.estimate().then((e=>({bytesUsed:e.usage,bytesRemaining:e.quota-e.usage}))).catch((e=>{throw new Error(`Unable to estimate web storage quota. Original error: ${e}`)}))}},w=x,P="SYNC_ONYX";function E(e){c.g.localStorage.setItem(P,e),c.g.localStorage.removeItem(P,e)}const I={...w,keepInstancesSync(e){this.setItem=(e,t)=>w.setItem(e,t).then((()=>E(e))),this.removeItem=e=>w.removeItem(e).then((()=>E(e))),this.removeItems=e=>w.removeItems(e).then((()=>{return t=e,void n().each(t,(e=>{E(e)}));var t})),this.mergeItem=(e,t,n)=>w.mergeItem(e,t,n).then((()=>E(e))),this.clear=()=>{let e;return w.getAllKeys().then((t=>{e=t})).then((()=>w.clear())).then((()=>{n().each(e,E)}))},c.g.addEventListener("storage",(t=>{if(t.key!==P||!t.newValue)return;const n=t.newValue;w.getItem(n).then((t=>e(n,t)))}))}},K=c(111).unstable_batchedUpdates,M={SET:"set",MERGE:"merge",MERGE_COLLECTION:"mergecollection",MULTI_SET:"multiset",CLEAR:"clear"},C={},T={};let j=0;const N={},A={};let R=new Map,L=[],U=[];const $={};let D={};const V=function(){const e={};return e.promise=new Promise((t=>{e.resolve=t})),e}();let q=null,W=[];function F(){return q||(q=new Promise((e=>{setTimeout((()=>{const t=W;W=[],q=null,K((()=>{t.forEach((e=>{e()}))})),e()}),0)})),q)}function _(e){return W.push(e),F()}const B=(e,t,n)=>t(e,n),z=(e,t,s)=>n().reduce(e,((e,n,r)=>(e[r]=B(n,t,s),e)),{});function G(e){return"object"==typeof e&&"compute"in e}function H(e){if(h.hasCacheForKey(e))return Promise.resolve(h.getValue(e));const t=`get:${e}`;if(h.hasPendingTask(t))return h.getTaskPromise(t);const n=I.getItem(e).then((t=>(h.set(e,t),t))).catch((t=>i(`Unable to get item from persistent storage. Key: ${e} Error: ${t}`)));return h.captureTask(t,n)}function Y(){const e=h.getAllKeys();if(e.length>0)return Promise.resolve(e);const t="getAllKeys";if(h.hasPendingTask(t))return h.getTaskPromise(t);const s=I.getAllKeys().then((e=>(n().each(e,(e=>h.addKey(e))),e)));return h.captureTask(t,s)}function Q(e){return R.has(e)}function X(e,t){return d(t,e)&&t.length>e.length}function J(e,t){return Q(e)?d(t,e):e===t}function Z(e){return n().some(U,(t=>J(t,e)))}function ee(e){return G(e)?e.cacheKey:e}function te(e){L=n().without(L,e)}function ne(e){!Q(e)&&Z(e)&&(te(e),L.push(e))}function se(e,t){$[e]=n().without($[e]||[],t),0===$[e].length&&delete $[e]}function re(e){const t=n().filter(h.getAllKeys(),(t=>X(e,t)));return n().reduce(t,((e,t)=>{const n=h.getValue(t);return n?(e[t]=n,e):e}),{})}function ie(e){const t=A[e];t&&t.forEach((e=>{h.drop(e),ie(e)}))}function oe(t,s){let r=!(arguments.length>2&&void 0!==arguments[2])||arguments[2],i=!(arguments.length>3&&void 0!==arguments[3])||arguments[3];ie(t);const o=n().keys(N);for(let a=0;a<o.length;a++){const c=N[o[a]];if(!c)continue;if(!d(c.key,t))continue;const l=c.key===t,y=X(t,c.key),h=re(t);if(n().isFunction(c.callback)){if(!r)continue;if(l){if(c.waitForCollectionCallback){c.callback(h);continue}const e=n().keys(s);for(let t=0;t<e.length;t++){const n=e[t];c.callback(h[n],n)}continue}if(y){c.callback(h[c.key],c.key);continue}}else if(c.withOnyxInstance){if(!i)continue;if(l){if(c.selector){c.withOnyxInstance.setStateProxy((t=>{const n=t[c.statePropertyName],s=z(h,c.selector,c.withOnyxInstance.state);return(0,e.deepEqual)(n,s)?null:{[c.statePropertyName]:s}}));continue}c.withOnyxInstance.setStateProxy((e=>{const r=n().clone(e[c.statePropertyName]||{}),i=n().keys(s);for(let e=0;e<i.length;e++){const t=i[e];r[t]=h[t]}return k(c,e[c.statePropertyName],r,"keysChanged",t),{[c.statePropertyName]:r}}));continue}if(y){const r=s[c.key];if(n().isUndefined(r))continue;if(c.selector){c.withOnyxInstance.setStateProxy((n=>{const s=n[c.statePropertyName],r=B(h[c.key],c.selector,c.withOnyxInstance.state);return(0,e.deepEqual)(s,r)?null:(k(c,s,r,"keysChanged",t),{[c.statePropertyName]:r})}));continue}c.withOnyxInstance.setStateProxy((e=>{const n=h[c.key],s=e[c.statePropertyName];return u.areObjectsEmpty(n,s)||n===s?null:(k(c,s,n,"keysChanged",t),{[c.statePropertyName]:n})}))}}}}function ae(t,s,r){let i=!(arguments.length>3&&void 0!==arguments[3])||arguments[3],o=!(arguments.length>4&&void 0!==arguments[4])||arguments[4];n().isNull(s)?te(t):ne(t),ie(t);const a=n().keys(N);for(let c=0;c<a.length;c++){const l=N[a[c]];if(l&&J(l.key,t)&&(!n().isFunction(r)||r(l)))if(n().isFunction(l.callback)){if(!i)continue;if(Q(l.key)&&l.waitForCollectionCallback){const e=re(l.key);e[t]=s,l.callback(e);continue}l.callback(s,t)}else if(l.withOnyxInstance){if(!o)continue;if(Q(l.key)){if(l.selector){l.withOnyxInstance.setStateProxy((n=>{const r=n[l.statePropertyName],i={[t]:B(s,l.selector,l.withOnyxInstance.state)},o={...r,...i};return(0,e.deepEqual)(r,o)?null:(k(l,r,i,"keyChanged",t),{[l.statePropertyName]:o})}));continue}l.withOnyxInstance.setStateProxy((e=>{const n=e[l.statePropertyName]||{},r={...n,[t]:s};return k(l,n,r,"keyChanged",t),{[l.statePropertyName]:r}}));continue}if(l.selector){l.withOnyxInstance.setStateProxy((t=>{const n=B(t[l.statePropertyName],l.selector,l.withOnyxInstance.state),r=B(s,l.selector,l.withOnyxInstance.state);return(0,e.deepEqual)(n,r)?null:{[l.statePropertyName]:r}}));continue}l.withOnyxInstance.setStateProxy((e=>{const n=e[l.statePropertyName];return u.areObjectsEmpty(s,n)||n===s?null:(k(l,n,s,"keyChanged",t),{[l.statePropertyName]:s})}))}else console.error("Warning: Found a matching subscriber to a key that changed, but no callback or withOnyxInstance could be found.")}}function ce(e,t,s,r){if(N[e.connectionID]){if(e.withOnyxInstance){let n=t;return e.selector&&(n=Q(e.key)?z(t,e.selector,e.withOnyxInstance.state):B(t,e.selector,e.withOnyxInstance.state)),k(e,null,n,"sendDataToConnection"),void(r?_((()=>{e.withOnyxInstance.setWithOnyxState(e.statePropertyName,n)})):e.withOnyxInstance.setWithOnyxState(e.statePropertyName,n))}n().isFunction(e.callback)&&e.callback(t,s)}}function le(e){if(Z(e.key)&&(h.removeLeastRecentlyUsedKeys(),e.withOnyxInstance&&!Q(e.key))){if(n().isUndefined(e.canEvict))throw new Error(`Cannot subscribe to safe eviction key '${e.key}' without providing a canEvict value.`);ne(ee(e.key))}}function ue(e,t){Promise.all(n().map(e,(e=>H(e)))).then((t=>n().reduce(t,((t,n,s)=>(t[e[s]]=n,t)),{}))).then((e=>ce(t,e,void 0,!0)))}function ye(e,t){let n=h.getValue(e.key.cacheKey);void 0===n&&(n=e.key.compute(t),h.set(e.key.cacheKey,n)),ce(e,n,e.key.cacheKey,!0)}function he(e,t,n){const s=Promise.resolve().then((()=>ae(e,t,n,!0,!1)));return _((()=>ae(e,t,n,!1,!0))),Promise.all([F(),s])}function de(e,t){const n=Promise.resolve().then((()=>oe(e,t,!0,!1)));return _((()=>oe(e,t,!1,!0))),Promise.all([F(),n])}function fe(e){return h.drop(e),he(e,null),I.removeItem(e)}function pe(){return I.getDatabaseSize().then((e=>{let{bytesUsed:t,bytesRemaining:n}=e;i(`Storage Quota Check -- bytesUsed: ${t} bytesRemaining: ${n}`)})).catch((e=>{r(`Unable to get database size. Error: ${e}`)}))}function me(e,t){for(var s=arguments.length,o=new Array(s>2?s-2:0),a=2;a<s;a++)o[a-2]=arguments[a];if(i(`Failed to save to storage. Error: ${e}. onyxMethod: ${t.name}`),e&&d(e.message,"Failed to execute 'put' on 'IDBObjectStore'"))throw r("Attempted to set invalid data set in Onyx. Please ensure all data is serializable."),e;const c=n().find(L,(e=>!$[e]));return c?(i(`Out of storage. Evicting least recently accessed key (${c}) and retrying.`),pe(),fe(c).then((()=>t(...o)))):(r("Out of storage. But found no acceptable keys to remove."),pe())}function ge(e,t,s,r){return i(`${r}() called for key: ${e}${n().isObject(t)?` properties: ${n().keys(t).join(",")}`:""}`),s?h.set(e,t):h.addToAccessedKeys(e),he(e,t,(e=>s||!1===e.initWithStoredValues))}function ve(e){return Boolean(C[e])}function ke(e,t){return n().isNull(t)?(fe(e),null):u.removeNestedNullValues(t)}function be(e,t){const n=ke(e,t);if(null===n)return Promise.resolve();ve(e)&&r(`Onyx.set() called after Onyx.merge() for key: ${e}. It is recommended to use set() or merge() not both.`);const s=h.hasValueChanged(e,n),i=ge(e,n,s,"set");return s?I.setItem(e,n).catch((t=>me(t,be,e,n))).then((()=>i)):i}function Oe(e){return n().map(e,((e,t)=>[t,e]))}function Se(e){const t=Oe(e),s=n().map(e,((e,t)=>(h.set(t,e),he(t,e)))),r=n().filter(n().map(t,(e=>{let[t,n]=e;const s=ke(t,n);if(null!==s)return[t,s]})),Boolean);return I.multiSet(r).catch((t=>me(t,Se,e))).then((()=>Promise.all(s)))}function xe(e,t,s){const r=n().last(t);return n().isArray(r)?r:n().some(t,n().isObject)?n().reduce(t,((e,t)=>u.fastMerge(e,t,s)),e||{}):r}function we(e,t){return n().isUndefined(t)?C[e]?T[e]:Promise.resolve():C[e]?(C[e].push(t),T[e]):(C[e]=[t],T[e]=H(e).then((t=>{try{let s=xe(void 0,C[e],!1);const r=n().includes(C[e],null);if(delete C[e],delete T[e],n().isNull(s))return void fe(e);const i=r?s:xe(t,[s],!0);t||(s=xe(void 0,[s],!0));const o=h.hasValueChanged(e,i),a=ge(e,i,o,"merge");return o?I.mergeItem(e,s,i).then((()=>a)):a}catch(t){return r(`An error occurred while applying merge for key: ${e}, Error: ${t}`),Promise.resolve()}})),T[e])}function Pe(){return I.multiGet(n().keys(D)).then((e=>{const t=n().object(e),s=u.fastMerge(t,D);h.merge(s),n().each(s,((e,t)=>ae(t,e)))}))}function Ee(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[];return Y().then((t=>{const s=[],r={},i={};n().each(t,(t=>{const o=n().contains(e,t),a=n().has(D,t);if(!o){const e=h.getValue(t),s=n().get(D,t,null);if(s!==e){h.set(t,s);const e=t.substring(0,t.indexOf("_")+1);e?(r[e]||(r[e]={}),r[e][t]=s):i[t]=s}}o||a||s.push(t)}));const o=[];n().each(i,((e,t)=>{o.push(he(t,e))})),n().each(r,((e,t)=>{o.push(de(t,e))}));const a=n().pairs(n().omit(D,e));return n().each(s,(e=>h.drop(e))),I.removeItems(s).then((()=>I.multiSet(a))).then((()=>Promise.all(o)))}))}function Ie(e,t){if(!n().isObject(t)||n().isArray(t)||n().isEmpty(t))return i("mergeCollection() called with invalid or empty value. Skipping this update."),Promise.resolve();let s=!1;return n().each(t,((t,n)=>{J(e,n)||(s=!0,r(`Provided collection doesn't have all its data belonging to the same parent. CollectionKey: ${e}, DataKey: ${n}`))})),s?Promise.resolve():Y().then((s=>{const[r,i]=n().chain(t).pick(((e,t)=>!n().isNull(e)||(fe(t),!1))).keys().partition((e=>s.includes(e))).value(),o=n().pick(t,r),a=n().pick(t,i),c=Oe(o),l=Oe(a),u=[];c.length>0&&u.push(I.multiMerge(c)),l.length>0&&u.push(I.multiSet(l));const y=Promise.all(n().map(r,H)).then((()=>(h.merge(t),de(e,t))));return Promise.all(u).catch((e=>me(e,Ie,t))).then((()=>y))}))}function Ke(e){n().each(e,(e=>{let{onyxMethod:t,key:s,value:r}=e;if(!n().contains([M.CLEAR,M.SET,M.MERGE,M.MERGE_COLLECTION,M.MULTI_SET],t))throw new Error(`Invalid onyxMethod ${t} in Onyx update.`);if(t===M.MULTI_SET){if(!n().isObject(r)||n().isArray(r)||n().isFunction(r))throw new Error("Invalid value provided in Onyx multiSet. Onyx multiSet value must be of type object.")}else if(t!==M.CLEAR&&!n().isString(s))throw new Error(`Invalid ${typeof s} key provided in Onyx update. Onyx key must be of type string.`)}));const t=[];let s=Promise.resolve();return n().each(e,(e=>{let{onyxMethod:n,key:r,value:i}=e;switch(n){case M.SET:t.push((()=>be(r,i)));break;case M.MERGE:t.push((()=>we(r,i)));break;case M.MERGE_COLLECTION:t.push((()=>Ie(r,i)));break;case M.MULTI_SET:t.push((()=>Se(i)));break;case M.CLEAR:s=Ee()}})),s.then((()=>Promise.all(n().map(t,(e=>e())))))}const Me={connect:function e(t){const s=j++;return N[s]=t,N[s].connectionID=s,G(t.key)?(V.promise.then((()=>le(t))).then((()=>{const r=t.key.dependencies||{},i=n().size(r);if(0===i)ye(t,{});else{N[s].dependencyConnections=[];const o={};n().each(r,((r,a)=>{const c=ee(r);A[c]=A[c]||new Set,A[c].add(t.key.cacheKey);const l=e({key:r,waitForCollectionCallback:!0,callback:e=>{o[a]=e,n().size(o)===i&&ye(t,o)}});N[s].dependencyConnections.push(l)}))}})),s):(!1===t.initWithStoredValues||V.promise.then((()=>le(t))).then((()=>Boolean(t.key)&&"string"==typeof t.key&&!t.key.endsWith("_")&&h.storageKeys.has(t.key)?[t.key]:Y())).then((e=>{const s=n().filter(e,(e=>J(t.key,e)));if(0===s.length)return t.key&&!Q(t.key)&&h.set(t.key,null),void ce(t,null,void 0,!1);if(n().isFunction(t.callback)){if(Q(t.key)){if(t.waitForCollectionCallback)return void ue(s,t);for(let e=0;e<s.length;e++)H(s[e]).then((n=>ce(t,n,s[e],!0)));return}H(t.key).then((e=>ce(t,e,t.key,!0)))}else{if(t.withOnyxInstance)return Q(t.key)?void ue(s,t):void H(t.key).then((e=>ce(t,e,t.key,!0)));console.error("Warning: Onyx.connect() was found without a callback or withOnyxInstance")}})),s)},disconnect:function e(t,n){N[t]&&(n&&se(n,t),N[t].dependencyConnections&&N[t].dependencyConnections.forEach((t=>e(t))),delete N[t])},set:be,multiSet:Se,merge:we,mergeCollection:Ie,update:Ke,clear:Ee,getAllKeys:Y,init:function(){let{keys:e={},initialKeyStates:t={},safeEvictionKeys:s=[],maxCachedKeysCount:r=1e3,captureMetrics:i=!1,shouldSyncMultipleInstances:o=Boolean(c.g.localStorage),debugSetState:a=!1}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};i&&function(){const e=c(378);H=e.decorateWithMetrics(H,"Onyx:get"),be=e.decorateWithMetrics(be,"Onyx:set"),Se=e.decorateWithMetrics(Se,"Onyx:multiSet"),Ee=e.decorateWithMetrics(Ee,"Onyx:clear"),we=e.decorateWithMetrics(we,"Onyx:merge"),Ie=e.decorateWithMetrics(Ie,"Onyx:mergeCollection"),Y=e.decorateWithMetrics(Y,"Onyx:getAllKeys"),Pe=e.decorateWithMetrics(Pe,"Onyx:defaults"),Ke=e.decorateWithMetrics(Ke,"Onyx:update"),Me.set=be,Me.multiSet=Se,Me.clear=Ee,Me.merge=we,Me.mergeCollection=Ie,Me.update=Ke,Me.getMetrics=e.getMetrics,Me.resetMetrics=e.resetMetrics,Me.printMetrics=e.printMetrics}(),a&&v(!0),r>0&&h.setRecentKeysLimit(r);const l=n().values(e.COLLECTION);R=n().reduce(l,((e,t)=>(e.set(t,!0),e)),new Map),D=t,U=s,Promise.all([Y().then((e=>{n().each(U,(t=>{n().each(e,(e=>{J(t,e)&&ne(e)}))}))})),Pe()]).then(V.resolve),o&&n().isFunction(I.keepInstancesSync)&&I.keepInstancesSync(((e,t)=>{h.set(e,t),ae(e,t)}))},registerLogger:function(e){s=e},addToEvictionBlockList:function(e,t){se(e,t),$[e]||($[e]=[]),$[e].push(t)},removeFromEvictionBlockList:se,isSafeEvictionKey:Z,METHOD:M,setMemoryOnlyKeys:function(e){I.setMemoryOnlyKeys(e),h.setRecentKeysLimit(1/0)},tryGetCachedValue:function e(t){let s=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(G(t)){let s=h.getValue(t.cacheKey);if(void 0!==s)return s;const r=n().mapObject(t.dependencies||{},(t=>e(t,{key:t})));return n().all(r,(e=>void 0!==e))?(s=t.compute(r),h.set(t.cacheKey,s),s):void 0}let r=h.getValue(t);if(Q(t)){const e=h.getAllKeys();if(0===e.length)return;const s=n().filter(e,(e=>e.startsWith(t)));r=n().reduce(s,((e,t)=>{const n=h.getValue(t);return n&&(e[t]=n),e}),{})}if(s.selector){const e=s.withOnyxInstance?s.withOnyxInstance.state:void 0;return Q(t)?z(r,s.selector,e):B(r,s.selector,e)}return r},hasPendingMergeForKey:ve,getCacheKey:ee},Ce=Me;var Te=c(697),je=c.n(Te),Ne=c(156),Ae=c.n(Ne);function Re(){return Re=Object.assign?Object.assign.bind():function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var s in n)Object.prototype.hasOwnProperty.call(n,s)&&(e[s]=n[s])}return e},Re.apply(this,arguments)}const Le=["initialValue","allowStaleData"],Ue=(e,t)=>n().pick(e,n().keys(t));function $e(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const s=n().chain(e).omit((e=>!1===e.initWithStoredValues)).keys().value();return r=>{const i=(o=r).displayName||o.name||"Component";var o;class a extends Ae().Component{constructor(r){var i,o,a;super(r),i=this,a=[],(o=function(e){var t=function(e,t){if("object"!=typeof e||null===e)return e;var n=e[Symbol.toPrimitive];if(void 0!==n){var s=n.call(e,"string");if("object"!=typeof s)return s;throw new TypeError("@@toPrimitive must return a primitive value.")}return String(e)}(e);return"symbol"==typeof t?t:String(t)}(o="pendingSetStates"))in i?Object.defineProperty(i,o,{value:a,enumerable:!0,configurable:!0,writable:!0}):i[o]=a,this.shouldDelayUpdates=t,this.setWithOnyxState=this.setWithOnyxState.bind(this),this.flushPendingSetStates=this.flushPendingSetStates.bind(this),this.activeConnectionIDs={};const c=n().reduce(e,((e,t,n)=>{const s=f(t.key,r);let i=Ce.tryGetCachedValue(s,t);return!i&&t.initialValue&&(i=t.initialValue),(void 0!==i&&!Ce.hasPendingMergeForKey(s)||t.allowStaleData)&&(e[n]=i),e}),{});c.loading=n().size(c)<s.length,this.tempState=c,this.state=c}componentDidMount(){const t=Ue(this.state,e);n().each(e,((e,s)=>{if(n().includes(Le,s))return;const r=f(e.key,{...this.props,...t});this.connectMappingToOnyx(e,s,r)})),this.checkEvictableKeys()}componentDidUpdate(t,s){const r=s.loading&&!this.state.loading,i=Ue(this.state,e),o=Ue(s,e);n().each(e,((e,s)=>{if(n().includes(Le,s))return;const a=Ce.getCacheKey(r?e.previousKey:f(e.key,{...t,...o})),c=Ce.getCacheKey(f(e.key,{...this.props,...i}));a!==c&&(Ce.disconnect(this.activeConnectionIDs[a],a),delete this.activeConnectionIDs[a],this.connectMappingToOnyx(e,s,c))})),this.checkEvictableKeys()}componentWillUnmount(){n().each(e,(t=>{const n=f(t.key,{...this.props,...Ue(this.state,e)});Ce.disconnect(this.activeConnectionIDs[n],n)}))}setStateProxy(e){this.shouldDelayUpdates?this.pendingSetStates.push(e):this.setState(e)}setWithOnyxState(t,r){const i=this.state[t];if(!this.state.loading||!this.tempState){if(i===r||u.areObjectsEmpty(i,r))return;return void this.setStateProxy({[t]:r})}if(this.tempState[t]=r,n().some(s,(e=>n().isUndefined(this.tempState[e]))))return;const o={...this.tempState};delete this.tempState,this.setState((t=>{const s=n().reduce(o,((s,r,i)=>{if("loading"===i)return s;const o=e[i].initialValue;return(n().isUndefined(o)||n().isUndefined(t[i])||t[i]===o)&&n().isUndefined(t[i])?s[i]=r:s[i]=t[i],s}),{});return s.loading=!1,s}))}checkEvictableKeys(){n().each(e,(e=>{if(n().isUndefined(e.canEvict))return;const t=f(e.canEvict,this.props),s=f(e.key,this.props);if(!Ce.isSafeEvictionKey(s))throw new Error(`canEvict can't be used on key '${s}'. This key must explicitly be flagged as safe for removal by adding it to Onyx.init({safeEvictionKeys: []}).`);t?Ce.removeFromEvictionBlockList(s,e.connectionID):Ce.addToEvictionBlockList(s,e.connectionID)}))}connectMappingToOnyx(t,n,s){e[n].previousKey=s,this.activeConnectionIDs[s]=Ce.connect({...t,key:s,statePropertyName:n,withOnyxInstance:this,displayName:i})}flushPendingSetStates(){this.shouldDelayUpdates&&(this.shouldDelayUpdates=!1,this.pendingSetStates.forEach((e=>{this.setState(e)})),this.pendingSetStates=[])}render(){const e=n().omit(this.props,n().isNull);if(this.state.loading)return null;let t=n().omit(this.state,"loading");return t=n().omit(t,n().isNull),Ae().createElement(r,Re({markReadyForHydration:this.flushPendingSetStates},e,t,{ref:this.props.forwardedRef}))}}return a.propTypes={forwardedRef:je().oneOfType([je().func,je().shape({current:je().object})])},a.defaultProps={forwardedRef:void 0},a.displayName=`withOnyx(${i})`,Ae().forwardRef(((e,t)=>{const n=a;return Ae().createElement(n,Re({},e,{forwardedRef:t}))}))}}const De=Ce})(),l})()));
//# sourceMappingURL=web.min.js.map